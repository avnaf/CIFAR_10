# ============================================================================================================================================= #
#Imports
import cv2
import numpy as np
# ============================================================================================================================================= #

# ============================================================================================================================================= #
#Globals:
batch_dir = r'C:\Users\Naftalis\Desktop\Computer Vision\Project\cifar-10-batches-py'
data_1 = batch_dir + '\\' + r'data_batch_1'
data_2 = batch_dir + '\\' + r'data_batch_2'
data_3 = batch_dir + '\\' + r'data_batch_3'
data_4 = batch_dir + '\\' + r'data_batch_4'
data_5 = batch_dir + '\\' + r'data_batch_5'
data_batch = [data_1, data_2, data_3, data_4, data_5]
test = batch_dir + '\\' + r'test_batch'

x_val = [2*i+1 for i in range(15)]
y_val = [2*i+1 for i in range(15)]
size_val = [i/2 for i in range(6)]
angle_val = [i for i in range(-90,90,30)]
print 'starting kp...'
g_key_points = [cv2.KeyPoint(x,y,size,angle) for x in x_val for y in y_val for size in size_val for angle in angle_val]
print g_key_points
print 'kp ended...'
# ============================================================================================================================================= #

# ============================================================================================================================================= #
# dict = {data : lables}
# data = 10000*3072 numpy array of uint8
#   Each row of the array stores a 32x32 colour image
#   The first 1024 entries contain the red channel values, the next 1024 the green, and the final 1024 the blue
#   The image is stored in row-major order, so that the first 32 entries of the array are the red channel values of the first row of the image
# lables =  list of 10000 numbers in the range 0-9
#   The number at index i indicates the label of the ith image in the array data
# ============================================================================================================================================= #
# The dataset contains another file, called batches.meta. It too contains a Python dictionary object. It has the following entries:
#   label_names = 10-element list which gives meaningful names to the numeric labels in the labels array described above.
#   For example, label_names[0] == "airplane", label_names[1] == "automobile", etc.
# ============================================================================================================================================= #
def unpickle(file, print_msg = False):
    if print_msg:
        print 'unpicking training set images'
        
    import cPickle
    with open(file, 'rb') as fo:
        dict = cPickle.load(fo)
    return dict

# ============================================================================================================================================= #
# input: array of 3072 elements
# ============================================================================================================================================= #
def img_2_RGB(im, print_msg = False):
    if print_msg:
        print 'reshaping image to RGB format (32*32*3)'
        
    mat = np.zeros((32,32,3), np.uint8)
    for i in range(32*32*3):
        mat[(i % (32*32)) // 32][i % 32][i // (32*32)] = im[i]
    return mat

# ============================================================================================================================================= #
# input: image list, heading (optional), delay [mili-seconds] (optional)
# ============================================================================================================================================= #
def show_img(i, heading = '', delay = 600):
    cv2.imshow(heading, i) 
    cv2.waitKey(delay)
    cv2.destroyAllWindows()

# ============================================================================================================================================= #
# 
# ============================================================================================================================================= #
def my_main(num_of_des, num_of_images_to_check = 10000):
    print '#'*100 
    print 'using {} descriptors'.format(num_of_des)
    d = unpickle(data_1)
    tst = unpickle(test)

    images = d.values()[0][:num_of_images_to_check]
    labels = d.values()[1][:num_of_images_to_check]
    
    tst_images = tst.values()[0][:num_of_images_to_check]
    tst_labels = tst.values()[1][:num_of_images_to_check]
        
    sift = cv2.xfeatures2d.SIFT_create()
    
    relevant_sized_descriptors = []
    relevant_labels = []
    
    for im,lb in zip(images, labels):
        im = img_2_RGB(im)
        #old_kp = sift.detect(im, None)
        kp,ds = sift.compute(im, g_key_points)
        
        #if ds is not None and len(ds) == num_of_des:
        relevant_sized_descriptors.append(ds.flatten())
        relevant_labels.append(lb)
                
            
    X = np.array(relevant_sized_descriptors)
    training_size = len(X)
    y = np.array(relevant_labels)
    
    from sklearn import svm
    
    clf1 = svm.LinearSVC(C=1)
    clf101 = svm.LinearSVC(C=0.1)
    clf102 = svm.LinearSVC(C=10)
    clf103 = svm.LinearSVC(C=100)
    clf2 = svm.SVR()
    clf30 = svm.SVC(C=1,kernel='rbf')
    clf31 = svm.SVC(C=10,kernel='rbf')
    clf32 = svm.SVC(C=100,kernel='rbf')
    clf4 = svm.SVC(C=0.01, kernel='poly', degree=3, gamma=2)
    clf5 = svm.SVC(C=0.01, kernel='poly', degree=4, gamma=2)
    clf6 = svm.SVC(C=0.05, kernel='poly', degree=3, gamma=2)
    clf7 = svm.SVC(C=1, kernel='poly', degree=4, gamma=2)#best so far
    clf71 = svm.SVC(C=0.05, kernel='poly', degree=4, gamma=1)#best so far
    clf72 = svm.SVC(C=0.05, kernel='poly', degree=4, gamma=5)#best so far
    clf73 = svm.SVC(C=0.05, kernel='poly', degree=4, gamma=10)#best so far
    clf74 = svm.SVC(C=0.05, kernel='poly', degree=4, gamma=0.25)#best so far
    clf8 = svm.SVC(C=0.01, kernel='poly', degree=5, gamma=2)
    clf9 = svm.SVC(C=0.1, kernel='poly', degree=4, gamma=2)
    clf10 = svm.SVC(C=0.1, kernel='poly', degree=5, gamma=2)
    clf11 = svm.SVC(C=0.3, kernel='poly', degree=4, gamma=2)
    clf12 = svm.SVC(C=0.5, kernel='poly', degree=4, gamma=2)
    clf13 = svm.SVC(C=1.0, kernel='poly', degree=4, gamma=2)
    clf14 = svm.SVC(C=2.0, kernel='poly', degree=4, gamma=2)
    
    
    clfs = [clf7]
    
    for clf in enumerate(clfs):
        print('fitting clf # {}'.format(clf[0]+1))
        clf[1].fit(X,y)
    
    relevant_sized_descriptors = []
    relevant_labels = []
        
    for im,lb in zip(tst_images, tst_labels):
        im = img_2_RGB(im)
        
        #old_kp = sift.detect(im, None)
        kp,ds = sift.compute(im, g_key_points)
        #print old_kp, kp, ds     
        
        #if ds is not None and len(ds) == num_of_des:
        relevant_sized_descriptors.append(ds.flatten())
        relevant_labels.append(lb)

    X = np.array(relevant_sized_descriptors)
    test_size = len(X)
    for clf in enumerate(clfs):
        print('training_size = {}, test_size = {}...clf # {}'.format(training_size,test_size,clf[0]+1), clf[1].score(X,relevant_labels))
            
    
        
    #clean-up
    del relevant_sized_descriptors
    del relevant_labels
    del X
    del y
    del clf
    del d
    del tst
    del images
    del labels
    del tst_images
    del tst_labels
    del sift
    
for i in range(20,25):
    my_main(i)
